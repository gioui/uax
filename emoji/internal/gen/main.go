/*
Package for a generator for UTS#51 Emoji character classes.

Content

Generator for Unicode Emoji code-point classes. For more information
see http://www.unicode.org/reports/tr51/#Emoji_Properties_and_Data_Files

Classes are generated from a companion file: "emoji-data.txt".

This creates a file "emojiclasses.go" in the current directory. It is designed
to be called from the "emoji" directory.


License

Governed by a 3-Clause BSD license. License file may be found in the root
folder of this module.

Copyright Â© 2021 Norbert Pillmayer <norbert@pillmayer.com>
*/
package main

import (
	"bytes"
	"flag"
	"go/format"
	"io/ioutil"
	"log"
	"runtime"
	"sort"
	"strings"
	"text/template"
	"unicode"

	"github.com/npillmayer/uax/internal/testdata"
	"github.com/npillmayer/uax/internal/ucdparse"
	"golang.org/x/text/unicode/rangetable"
)

func main() {
	flag.Parse()

	codePointLists, err := loadUnicodeEmojiBreakFile()
	checkFatal(err)

	classes := []string{}
	for class := range codePointLists {
		classes = append(classes, class)
	}
	sort.Strings(classes)

	var w bytes.Buffer
	terr := T.Execute(&w, map[string]interface{}{
		"Classes":    classes,
		"Codepoints": codePointLists,
	})
	checkFatal(terr)

	formatted, err := format.Source(w.Bytes())
	checkFatal(err)

	err = ioutil.WriteFile("emojiclasses.go", formatted, 0644)
	checkFatal(err)
}

// Load the Unicode UAX#29 definition file: EmojiBreakProperty.txt
func loadUnicodeEmojiBreakFile() (map[string][]rune, error) {
	parser, err := ucdparse.New(bytes.NewReader(testdata.EmojiBreakProperty))
	if err != nil {
		return nil, err
	}
	runeranges := map[string][]rune{}
	for parser.Next() {
		from, to := parser.Token.Range()
		clstr := strings.TrimSpace(parser.Token.Field(1))
		if clstr == "" {
			// Not quite sure why this happens.
			log.Println("found empty line")
			continue
		}
		list := runeranges[clstr]
		for r := from; r <= to; r++ {
			list = append(list, r)
		}
		runeranges[clstr] = list
	}
	err = parser.Token.Error
	if err != nil {
		log.Fatal(err)
	}
	return runeranges, err
}

var T = template.Must(template.New("").Funcs(template.FuncMap{
	"rangetable": func(runes []rune) *unicode.RangeTable {
		return rangetable.New(runes...)
	},
}).Parse(`package emoji

// Code generated by github.com/npillmayer/uax/uax14/internal/generator  DO NOT EDIT
//
// BSD License, Copyright (c) 2018, Norbert Pillmayer (norbert@pillmayer.com)

import (
    "strconv"
    "unicode"
)

// Type for UTS#51 emoji code-point classes.
// Must be convertable to int.
type EmojisClass int

// These are all the UAX#51 breaking classes.
const (
{{ range $i, $class := .Classes }}
	{{$class}}Class EmojisClass = {{$i}}
{{- end }}

    sot EmojisClass = 1000 // pseudo class "start of text"
    eot EmojisClass = 1001 // pseudo class "end of text"
)

// Range tables for UAX#51 code-point classes.
// Clients can check with unicode.Is(..., rune)
var (
{{ range $i, $class := .Classes }}
	{{$class}} = _{{$class}}
{{- end }}
)

// Stringer for type EmojisClass
func (c EmojisClass) String() string {
	switch c {
	case sot: return "sot"
	case eot: return "eot"
	default:
		return "EmojisClass(" + strconv.Itoa(int(c)) + ")"
{{- range $i, $class := .Classes }}
	case {{$class}}Class: return "{{ $class }}Class"
{{- end }}
	}
}

var rangeFromEmojisClass = []*unicode.RangeTable{
{{- range $i, $class := .Classes }}
	{{$class}}Class: {{$class}},
{{- end }}
}


// range table definitions, these are separate from the public definitions
// to make documentation readable.
var (
{{- range $class, $runes := .Codepoints }}
	_{{ $class }} = {{ printf "%#v" (rangetable $runes) }}
{{- end }}
)
`))

// --- Util -------------------------------------------------------------

func checkFatal(err error) {
	_, file, line, _ := runtime.Caller(1)
	if err != nil {
		log.Fatalln(":", file, ":", line, "-", err)
	}
}
